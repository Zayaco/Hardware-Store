{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { of, fromEvent } from 'rxjs';\nimport { mergeMap, map, tap, filter, throttleTime } from 'rxjs/operators';\nclass NgxInfiniteScrollService {\n  constructor() {}\n}\nNgxInfiniteScrollService.ɵfac = function NgxInfiniteScrollService_Factory(t) {\n  return new (t || NgxInfiniteScrollService)();\n};\nNgxInfiniteScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxInfiniteScrollService,\n  factory: NgxInfiniteScrollService.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxInfiniteScrollService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n  const hasWindow = window && !!window.document && window.document.documentElement;\n  let container = hasWindow && scrollWindow ? window : defaultElement;\n  if (selector) {\n    const containerIsString = selector && hasWindow && typeof selector === 'string';\n    container = containerIsString ? findElement(selector, defaultElement.nativeElement, fromRoot) : selector;\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n  return container;\n}\nfunction findElement(selector, customRoot, fromRoot) {\n  const rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\nfunction inputPropChanged(prop) {\n  return prop && !prop.firstChange;\n}\nfunction hasWindowDefined() {\n  return typeof window !== 'undefined';\n}\nconst VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\nconst HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\nclass AxisResolver {\n  constructor(vertical = true) {\n    this.vertical = vertical;\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n  clientHeightKey() {\n    return this.propsMap.clientHeight;\n  }\n  offsetHeightKey() {\n    return this.propsMap.offsetHeight;\n  }\n  scrollHeightKey() {\n    return this.propsMap.scrollHeight;\n  }\n  pageYOffsetKey() {\n    return this.propsMap.pageYOffset;\n  }\n  offsetTopKey() {\n    return this.propsMap.offsetTop;\n  }\n  scrollTopKey() {\n    return this.propsMap.scrollTop;\n  }\n  topKey() {\n    return this.propsMap.top;\n  }\n}\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n  return false;\n}\nfunction createResolver({\n  windowElement,\n  axis\n}) {\n  return createResolverWithContainer({\n    axis,\n    isWindow: isElementWindow(windowElement)\n  }, windowElement);\n}\nfunction createResolverWithContainer(resolver, windowElement) {\n  const container = resolver.isWindow || windowElement && !windowElement.nativeElement ? windowElement : windowElement.nativeElement;\n  return {\n    ...resolver,\n    container\n  };\n}\nfunction isElementWindow(windowElement) {\n  const isWindow = ['Window', 'global'].some(obj => Object.prototype.toString.call(windowElement).includes(obj));\n  return isWindow;\n}\nfunction getDocumentElement(isContainerWindow, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\nfunction calculatePoints(element, resolver) {\n  const height = extractHeightForElement(resolver);\n  return resolver.isWindow ? calculatePointsForWindow(height, element, resolver) : calculatePointsForElement(height, element, resolver);\n}\nfunction calculatePointsForWindow(height, element, resolver) {\n  const {\n    axis,\n    container,\n    isWindow\n  } = resolver;\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis);\n  // scrolled until now / current y point\n  const scrolled = height + getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n  // total height / most bottom y point\n  const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n  const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow\n  };\n}\nfunction calculatePointsForElement(height, element, resolver) {\n  const {\n    axis,\n    container\n  } = resolver;\n  // perhaps use container.offsetTop instead of 'scrollTop'\n  const scrolled = container[axis.scrollTopKey()];\n  const totalToScroll = container[axis.scrollHeightKey()];\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow: false\n  };\n}\nfunction extractHeightPropKeys(axis) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\nfunction extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}) {\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis);\n  return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n  if (isNaN(elem[offsetHeightKey])) {\n    const docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\nfunction getElementOffsetTop(elem, axis, isWindow) {\n  const topKey = axis.topKey();\n  // elem = elem.nativeElement;\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n  return elem.getBoundingClientRect()[topKey] + getElementPageYOffset(elem, axis, isWindow);\n}\nfunction getElementPageYOffset(elem, axis, isWindow) {\n  const pageYOffset = axis.pageYOffsetKey();\n  const scrollTop = axis.scrollTopKey();\n  const offsetTop = axis.offsetTopKey();\n  if (isNaN(window.pageYOffset)) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\nfunction shouldFireScrollEvent(container, distance = {\n  down: 0,\n  up: 0\n}, scrollingDown) {\n  let remaining;\n  let containerBreakpoint;\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n  const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    const distanceDown = distance?.down ? distance.down : 0;\n    containerBreakpoint = distanceDown / 10;\n  } else {\n    const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    const distanceUp = distance?.up ? distance.up : 0;\n    containerBreakpoint = distanceUp / 10;\n  }\n  const shouldFireEvent = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\nfunction isScrollingDownwards(lastScrollPosition, container) {\n  return lastScrollPosition < container.scrolled;\n}\nfunction getScrollStats(lastScrollPosition, container, distance) {\n  const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown\n  };\n}\nfunction updateScrollPosition(position, scrollState) {\n  return scrollState.lastScrollPosition = position;\n}\nfunction updateTotalToScroll(totalToScroll, scrollState) {\n  if (scrollState.lastTotalToScroll !== totalToScroll) {\n    scrollState.lastTotalToScroll = scrollState.totalToScroll;\n    scrollState.totalToScroll = totalToScroll;\n  }\n}\nfunction isSameTotalToScroll(scrollState) {\n  return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\nfunction updateTriggeredFlag(scroll, scrollState, triggered, isScrollingDown) {\n  if (isScrollingDown) {\n    scrollState.triggered.down = scroll;\n  } else {\n    scrollState.triggered.up = scroll;\n  }\n}\nfunction isTriggeredScroll(totalToScroll, scrollState, isScrollingDown) {\n  return isScrollingDown ? scrollState.triggered.down === totalToScroll : scrollState.triggered.up === totalToScroll;\n}\nfunction updateScrollState(scrollState, scrolledUntilNow, totalToScroll) {\n  updateScrollPosition(scrolledUntilNow, scrollState);\n  updateTotalToScroll(totalToScroll, scrollState);\n  // const isSameTotal = isSameTotalToScroll(scrollState);\n  // if (!isSameTotal) {\n  //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n  // }\n}\n\nclass ScrollState {\n  constructor({\n    totalToScroll\n  }) {\n    this.lastScrollPosition = 0;\n    this.lastTotalToScroll = 0;\n    this.totalToScroll = 0;\n    this.triggered = {\n      down: 0,\n      up: 0\n    };\n    this.totalToScroll = totalToScroll;\n  }\n  updateScrollPosition(position) {\n    return this.lastScrollPosition = position;\n  }\n  updateTotalToScroll(totalToScroll) {\n    if (this.lastTotalToScroll !== totalToScroll) {\n      this.lastTotalToScroll = this.totalToScroll;\n      this.totalToScroll = totalToScroll;\n    }\n  }\n  updateScroll(scrolledUntilNow, totalToScroll) {\n    this.updateScrollPosition(scrolledUntilNow);\n    this.updateTotalToScroll(totalToScroll);\n  }\n  updateTriggeredFlag(scroll, isScrollingDown) {\n    if (isScrollingDown) {\n      this.triggered.down = scroll;\n    } else {\n      this.triggered.up = scroll;\n    }\n  }\n  isTriggeredScroll(totalToScroll, isScrollingDown) {\n    return isScrollingDown ? this.triggered.down === totalToScroll : this.triggered.up === totalToScroll;\n  }\n}\nfunction createScroller(config) {\n  const {\n    scrollContainer,\n    scrollWindow,\n    element,\n    fromRoot\n  } = config;\n  const resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  const scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver)\n  });\n  const options = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  const distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map(positionStats => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({\n    stats\n  }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({\n    fire,\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => {\n    scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n  }), map(toInfiniteScrollAction));\n}\nfunction attachScrollEvent(options) {\n  let obs = fromEvent(options.container, 'scroll');\n  // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // Replacing with throttleTime seems to solve the problem\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n  if (options.throttle) {\n    obs = obs.pipe(throttleTime(options.throttle, undefined, {\n      leading: true,\n      trailing: true\n    }));\n  }\n  return obs;\n}\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n  const {\n    scrollDown,\n    fire\n  } = getScrollStats(lastScrollPosition, stats, distance);\n  return {\n    scrollDown,\n    fire,\n    stats\n  };\n}\nconst InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\nfunction toInfiniteScrollAction(response) {\n  const {\n    scrollDown,\n    stats: {\n      scrolled: currentScrollPosition\n    }\n  } = response;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition\n    }\n  };\n}\nclass InfiniteScrollDirective {\n  constructor(element, zone) {\n    this.element = element;\n    this.zone = zone;\n    this.scrolled = new EventEmitter();\n    this.scrolledUp = new EventEmitter();\n    this.infiniteScrollDistance = 2;\n    this.infiniteScrollUpDistance = 1.5;\n    this.infiniteScrollThrottle = 150;\n    this.infiniteScrollDisabled = false;\n    this.infiniteScrollContainer = null;\n    this.scrollWindow = true;\n    this.immediateCheck = false;\n    this.horizontal = false;\n    this.alwaysCallback = false;\n    this.fromRoot = false;\n  }\n  ngAfterViewInit() {\n    if (!this.infiniteScrollDisabled) {\n      this.setup();\n    }\n  }\n  ngOnChanges({\n    infiniteScrollContainer,\n    infiniteScrollDisabled,\n    infiniteScrollDistance\n  }) {\n    const containerChanged = inputPropChanged(infiniteScrollContainer);\n    const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n    const distanceChanged = inputPropChanged(infiniteScrollDistance);\n    const shouldSetup = !disabledChanged && !this.infiniteScrollDisabled || disabledChanged && !infiniteScrollDisabled.currentValue || distanceChanged;\n    if (containerChanged || disabledChanged || distanceChanged) {\n      this.destroyScroller();\n      if (shouldSetup) {\n        this.setup();\n      }\n    }\n  }\n  setup() {\n    if (hasWindowDefined()) {\n      this.zone.runOutsideAngular(() => {\n        this.disposeScroller = createScroller({\n          fromRoot: this.fromRoot,\n          alwaysCallback: this.alwaysCallback,\n          disable: this.infiniteScrollDisabled,\n          downDistance: this.infiniteScrollDistance,\n          element: this.element,\n          horizontal: this.horizontal,\n          scrollContainer: this.infiniteScrollContainer,\n          scrollWindow: this.scrollWindow,\n          throttle: this.infiniteScrollThrottle,\n          upDistance: this.infiniteScrollUpDistance\n        }).subscribe(payload => this.handleOnScroll(payload));\n      });\n    }\n  }\n  handleOnScroll({\n    type,\n    payload\n  }) {\n    const emitter = type === InfiniteScrollActions.DOWN ? this.scrolled : this.scrolledUp;\n    if (hasObservers(emitter)) {\n      this.zone.run(() => emitter.emit(payload));\n    }\n  }\n  ngOnDestroy() {\n    this.destroyScroller();\n  }\n  destroyScroller() {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\n}\nInfiniteScrollDirective.ɵfac = function InfiniteScrollDirective_Factory(t) {\n  return new (t || InfiniteScrollDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\nInfiniteScrollDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: InfiniteScrollDirective,\n  selectors: [[\"\", \"infiniteScroll\", \"\"], [\"\", \"infinite-scroll\", \"\"], [\"\", \"data-infinite-scroll\", \"\"]],\n  inputs: {\n    infiniteScrollDistance: \"infiniteScrollDistance\",\n    infiniteScrollUpDistance: \"infiniteScrollUpDistance\",\n    infiniteScrollThrottle: \"infiniteScrollThrottle\",\n    infiniteScrollDisabled: \"infiniteScrollDisabled\",\n    infiniteScrollContainer: \"infiniteScrollContainer\",\n    scrollWindow: \"scrollWindow\",\n    immediateCheck: \"immediateCheck\",\n    horizontal: \"horizontal\",\n    alwaysCallback: \"alwaysCallback\",\n    fromRoot: \"fromRoot\"\n  },\n  outputs: {\n    scrolled: \"scrolled\",\n    scrolledUp: \"scrolledUp\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InfiniteScrollDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    scrolled: [{\n      type: Output\n    }],\n    scrolledUp: [{\n      type: Output\n    }],\n    infiniteScrollDistance: [{\n      type: Input\n    }],\n    infiniteScrollUpDistance: [{\n      type: Input\n    }],\n    infiniteScrollThrottle: [{\n      type: Input\n    }],\n    infiniteScrollDisabled: [{\n      type: Input\n    }],\n    infiniteScrollContainer: [{\n      type: Input\n    }],\n    scrollWindow: [{\n      type: Input\n    }],\n    immediateCheck: [{\n      type: Input\n    }],\n    horizontal: [{\n      type: Input\n    }],\n    alwaysCallback: [{\n      type: Input\n    }],\n    fromRoot: [{\n      type: Input\n    }]\n  });\n})();\nfunction hasObservers(emitter) {\n  // Note: The `observed` property is available only in RxJS@7.2.0, which means it's\n  // not available for users running the lower version.\n  return emitter.observed ?? emitter.observers.length > 0;\n}\nclass InfiniteScrollModule {}\nInfiniteScrollModule.ɵfac = function InfiniteScrollModule_Factory(t) {\n  return new (t || InfiniteScrollModule)();\n};\nInfiniteScrollModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: InfiniteScrollModule\n});\nInfiniteScrollModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InfiniteScrollModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [InfiniteScrollDirective],\n      exports: [InfiniteScrollDirective],\n      imports: [],\n      providers: []\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ngx-infinite-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule, NgxInfiniteScrollService };","map":{"version":3,"names":["i0","Injectable","EventEmitter","Directive","Output","Input","NgModule","of","fromEvent","mergeMap","map","tap","filter","throttleTime","NgxInfiniteScrollService","constructor","ɵfac","ɵprov","type","args","providedIn","resolveContainerElement","selector","scrollWindow","defaultElement","fromRoot","hasWindow","window","document","documentElement","container","containerIsString","findElement","nativeElement","Error","customRoot","rootEl","querySelector","inputPropChanged","prop","firstChange","hasWindowDefined","VerticalProps","clientHeight","offsetHeight","scrollHeight","pageYOffset","offsetTop","scrollTop","top","HorizontalProps","AxisResolver","vertical","propsMap","clientHeightKey","offsetHeightKey","scrollHeightKey","pageYOffsetKey","offsetTopKey","scrollTopKey","topKey","shouldTriggerEvents","alwaysCallback","shouldFireScrollEvent","isTriggeredCurrentTotal","createResolver","windowElement","axis","createResolverWithContainer","isWindow","isElementWindow","resolver","some","obj","Object","prototype","toString","call","includes","getDocumentElement","isContainerWindow","calculatePoints","element","height","extractHeightForElement","calculatePointsForWindow","calculatePointsForElement","extractHeightPropKeys","scrolled","getElementPageYOffset","nativeElementHeight","getElementHeight","totalToScroll","getElementOffsetTop","elem","isNaN","docElem","getBoundingClientRect","ownerDocument","defaultView","distance","down","up","scrollingDown","remaining","containerBreakpoint","scrolledUntilNow","distanceDown","totalHiddenContentHeight","distanceUp","shouldFireEvent","isScrollingDownwards","lastScrollPosition","getScrollStats","scrollDown","fire","updateScrollPosition","position","scrollState","updateTotalToScroll","lastTotalToScroll","isSameTotalToScroll","updateTriggeredFlag","scroll","triggered","isScrollingDown","isTriggeredScroll","updateScrollState","ScrollState","updateScroll","createScroller","config","scrollContainer","horizontal","options","throttle","upDistance","downDistance","attachScrollEvent","pipe","positionStats","toInfiniteScrollParams","stats","toInfiniteScrollAction","obs","undefined","leading","trailing","InfiniteScrollActions","DOWN","UP","response","currentScrollPosition","payload","InfiniteScrollDirective","zone","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","immediateCheck","ngAfterViewInit","setup","ngOnChanges","containerChanged","disabledChanged","distanceChanged","shouldSetup","currentValue","destroyScroller","runOutsideAngular","disposeScroller","disable","subscribe","handleOnScroll","emitter","hasObservers","run","emit","ngOnDestroy","unsubscribe","ElementRef","NgZone","ɵdir","observed","observers","length","InfiniteScrollModule","ɵmod","ɵinj","declarations","exports","imports","providers"],"sources":["C:/Users/Nicol/source/repos/Zayaco/Hardware-Store/Ferretería/ClientApp/node_modules/ngx-infinite-scroll/fesm2020/ngx-infinite-scroll.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { of, fromEvent } from 'rxjs';\nimport { mergeMap, map, tap, filter, throttleTime } from 'rxjs/operators';\n\nclass NgxInfiniteScrollService {\n    constructor() { }\n}\nNgxInfiniteScrollService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: NgxInfiniteScrollService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNgxInfiniteScrollService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: NgxInfiniteScrollService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: NgxInfiniteScrollService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: function () { return []; } });\n\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n    const hasWindow = window && !!window.document && window.document.documentElement;\n    let container = hasWindow && scrollWindow ? window : defaultElement;\n    if (selector) {\n        const containerIsString = selector && hasWindow && typeof selector === 'string';\n        container = containerIsString\n            ? findElement(selector, defaultElement.nativeElement, fromRoot)\n            : selector;\n        if (!container) {\n            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n        }\n    }\n    return container;\n}\nfunction findElement(selector, customRoot, fromRoot) {\n    const rootEl = fromRoot ? window.document : customRoot;\n    return rootEl.querySelector(selector);\n}\nfunction inputPropChanged(prop) {\n    return prop && !prop.firstChange;\n}\nfunction hasWindowDefined() {\n    return typeof window !== 'undefined';\n}\n\nconst VerticalProps = {\n    clientHeight: \"clientHeight\",\n    offsetHeight: \"offsetHeight\",\n    scrollHeight: \"scrollHeight\",\n    pageYOffset: \"pageYOffset\",\n    offsetTop: \"offsetTop\",\n    scrollTop: \"scrollTop\",\n    top: \"top\"\n};\nconst HorizontalProps = {\n    clientHeight: \"clientWidth\",\n    offsetHeight: \"offsetWidth\",\n    scrollHeight: \"scrollWidth\",\n    pageYOffset: \"pageXOffset\",\n    offsetTop: \"offsetLeft\",\n    scrollTop: \"scrollLeft\",\n    top: \"left\"\n};\nclass AxisResolver {\n    constructor(vertical = true) {\n        this.vertical = vertical;\n        this.propsMap = vertical ? VerticalProps : HorizontalProps;\n    }\n    clientHeightKey() {\n        return this.propsMap.clientHeight;\n    }\n    offsetHeightKey() {\n        return this.propsMap.offsetHeight;\n    }\n    scrollHeightKey() {\n        return this.propsMap.scrollHeight;\n    }\n    pageYOffsetKey() {\n        return this.propsMap.pageYOffset;\n    }\n    offsetTopKey() {\n        return this.propsMap.offsetTop;\n    }\n    scrollTopKey() {\n        return this.propsMap.scrollTop;\n    }\n    topKey() {\n        return this.propsMap.top;\n    }\n}\n\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n    if (alwaysCallback && shouldFireScrollEvent) {\n        return true;\n    }\n    if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n        return true;\n    }\n    return false;\n}\n\nfunction createResolver({ windowElement, axis, }) {\n    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);\n}\nfunction createResolverWithContainer(resolver, windowElement) {\n    const container = resolver.isWindow || (windowElement && !windowElement.nativeElement)\n        ? windowElement\n        : windowElement.nativeElement;\n    return { ...resolver, container };\n}\nfunction isElementWindow(windowElement) {\n    const isWindow = ['Window', 'global'].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));\n    return isWindow;\n}\nfunction getDocumentElement(isContainerWindow, windowElement) {\n    return isContainerWindow ? windowElement.document.documentElement : null;\n}\nfunction calculatePoints(element, resolver) {\n    const height = extractHeightForElement(resolver);\n    return resolver.isWindow\n        ? calculatePointsForWindow(height, element, resolver)\n        : calculatePointsForElement(height, element, resolver);\n}\nfunction calculatePointsForWindow(height, element, resolver) {\n    const { axis, container, isWindow } = resolver;\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    // scrolled until now / current y point\n    const scrolled = height +\n        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +\n        nativeElementHeight;\n    return { height, scrolled, totalToScroll, isWindow };\n}\nfunction calculatePointsForElement(height, element, resolver) {\n    const { axis, container } = resolver;\n    // perhaps use container.offsetTop instead of 'scrollTop'\n    const scrolled = container[axis.scrollTopKey()];\n    const totalToScroll = container[axis.scrollHeightKey()];\n    return { height, scrolled, totalToScroll, isWindow: false };\n}\nfunction extractHeightPropKeys(axis) {\n    return {\n        offsetHeightKey: axis.offsetHeightKey(),\n        clientHeightKey: axis.clientHeightKey(),\n    };\n}\nfunction extractHeightForElement({ container, isWindow, axis, }) {\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n    if (isNaN(elem[offsetHeightKey])) {\n        const docElem = getDocumentElement(isWindow, elem);\n        return docElem ? docElem[clientHeightKey] : 0;\n    }\n    else {\n        return elem[offsetHeightKey];\n    }\n}\nfunction getElementOffsetTop(elem, axis, isWindow) {\n    const topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) {\n        // || elem.css('none')) {\n        return;\n    }\n    return (elem.getBoundingClientRect()[topKey] +\n        getElementPageYOffset(elem, axis, isWindow));\n}\nfunction getElementPageYOffset(elem, axis, isWindow) {\n    const pageYOffset = axis.pageYOffsetKey();\n    const scrollTop = axis.scrollTopKey();\n    const offsetTop = axis.offsetTopKey();\n    if (isNaN(window.pageYOffset)) {\n        return getDocumentElement(isWindow, elem)[scrollTop];\n    }\n    else if (elem.ownerDocument) {\n        return elem.ownerDocument.defaultView[pageYOffset];\n    }\n    else {\n        return elem[offsetTop];\n    }\n}\n\nfunction shouldFireScrollEvent(container, distance = { down: 0, up: 0 }, scrollingDown) {\n    let remaining;\n    let containerBreakpoint;\n    if (container.totalToScroll <= 0) {\n        return false;\n    }\n    const scrolledUntilNow = container.isWindow\n        ? container.scrolled\n        : container.height + container.scrolled;\n    if (scrollingDown) {\n        remaining =\n            (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n        const distanceDown = distance?.down ? distance.down : 0;\n        containerBreakpoint = distanceDown / 10;\n    }\n    else {\n        const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n        remaining = container.scrolled / totalHiddenContentHeight;\n        const distanceUp = distance?.up ? distance.up : 0;\n        containerBreakpoint = distanceUp / 10;\n    }\n    const shouldFireEvent = remaining <= containerBreakpoint;\n    return shouldFireEvent;\n}\nfunction isScrollingDownwards(lastScrollPosition, container) {\n    return lastScrollPosition < container.scrolled;\n}\nfunction getScrollStats(lastScrollPosition, container, distance) {\n    const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n    return {\n        fire: shouldFireScrollEvent(container, distance, scrollDown),\n        scrollDown,\n    };\n}\nfunction updateScrollPosition(position, scrollState) {\n    return (scrollState.lastScrollPosition = position);\n}\nfunction updateTotalToScroll(totalToScroll, scrollState) {\n    if (scrollState.lastTotalToScroll !== totalToScroll) {\n        scrollState.lastTotalToScroll = scrollState.totalToScroll;\n        scrollState.totalToScroll = totalToScroll;\n    }\n}\nfunction isSameTotalToScroll(scrollState) {\n    return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\nfunction updateTriggeredFlag(scroll, scrollState, triggered, isScrollingDown) {\n    if (isScrollingDown) {\n        scrollState.triggered.down = scroll;\n    }\n    else {\n        scrollState.triggered.up = scroll;\n    }\n}\nfunction isTriggeredScroll(totalToScroll, scrollState, isScrollingDown) {\n    return isScrollingDown\n        ? scrollState.triggered.down === totalToScroll\n        : scrollState.triggered.up === totalToScroll;\n}\nfunction updateScrollState(scrollState, scrolledUntilNow, totalToScroll) {\n    updateScrollPosition(scrolledUntilNow, scrollState);\n    updateTotalToScroll(totalToScroll, scrollState);\n    // const isSameTotal = isSameTotalToScroll(scrollState);\n    // if (!isSameTotal) {\n    //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n    // }\n}\n\nclass ScrollState {\n    constructor({ totalToScroll }) {\n        this.lastScrollPosition = 0;\n        this.lastTotalToScroll = 0;\n        this.totalToScroll = 0;\n        this.triggered = {\n            down: 0,\n            up: 0,\n        };\n        this.totalToScroll = totalToScroll;\n    }\n    updateScrollPosition(position) {\n        return (this.lastScrollPosition = position);\n    }\n    updateTotalToScroll(totalToScroll) {\n        if (this.lastTotalToScroll !== totalToScroll) {\n            this.lastTotalToScroll = this.totalToScroll;\n            this.totalToScroll = totalToScroll;\n        }\n    }\n    updateScroll(scrolledUntilNow, totalToScroll) {\n        this.updateScrollPosition(scrolledUntilNow);\n        this.updateTotalToScroll(totalToScroll);\n    }\n    updateTriggeredFlag(scroll, isScrollingDown) {\n        if (isScrollingDown) {\n            this.triggered.down = scroll;\n        }\n        else {\n            this.triggered.up = scroll;\n        }\n    }\n    isTriggeredScroll(totalToScroll, isScrollingDown) {\n        return isScrollingDown\n            ? this.triggered.down === totalToScroll\n            : this.triggered.up === totalToScroll;\n    }\n}\n\nfunction createScroller(config) {\n    const { scrollContainer, scrollWindow, element, fromRoot } = config;\n    const resolver = createResolver({\n        axis: new AxisResolver(!config.horizontal),\n        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot),\n    });\n    const scrollState = new ScrollState({\n        totalToScroll: calculatePoints(element, resolver),\n    });\n    const options = {\n        container: resolver.container,\n        throttle: config.throttle,\n    };\n    const distance = {\n        up: config.upDistance,\n        down: config.downDistance,\n    };\n    return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map((positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({ stats }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({ fire, scrollDown, stats: { totalToScroll } }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({ scrollDown, stats: { totalToScroll } }) => {\n        scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    }), map(toInfiniteScrollAction));\n}\nfunction attachScrollEvent(options) {\n    let obs = fromEvent(options.container, 'scroll');\n    // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n    // Let's avoid calling the function unless needed.\n    // Replacing with throttleTime seems to solve the problem\n    // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n    if (options.throttle) {\n        obs = obs.pipe(throttleTime(options.throttle, undefined, {\n            leading: true,\n            trailing: true,\n        }));\n    }\n    return obs;\n}\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n    const { scrollDown, fire } = getScrollStats(lastScrollPosition, stats, distance);\n    return {\n        scrollDown,\n        fire,\n        stats,\n    };\n}\nconst InfiniteScrollActions = {\n    DOWN: '[NGX_ISE] DOWN',\n    UP: '[NGX_ISE] UP',\n};\nfunction toInfiniteScrollAction(response) {\n    const { scrollDown, stats: { scrolled: currentScrollPosition }, } = response;\n    return {\n        type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n        payload: {\n            currentScrollPosition,\n        },\n    };\n}\n\nclass InfiniteScrollDirective {\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.scrolled = new EventEmitter();\n        this.scrolledUp = new EventEmitter();\n        this.infiniteScrollDistance = 2;\n        this.infiniteScrollUpDistance = 1.5;\n        this.infiniteScrollThrottle = 150;\n        this.infiniteScrollDisabled = false;\n        this.infiniteScrollContainer = null;\n        this.scrollWindow = true;\n        this.immediateCheck = false;\n        this.horizontal = false;\n        this.alwaysCallback = false;\n        this.fromRoot = false;\n    }\n    ngAfterViewInit() {\n        if (!this.infiniteScrollDisabled) {\n            this.setup();\n        }\n    }\n    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance, }) {\n        const containerChanged = inputPropChanged(infiniteScrollContainer);\n        const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n        const distanceChanged = inputPropChanged(infiniteScrollDistance);\n        const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n            (disabledChanged && !infiniteScrollDisabled.currentValue) ||\n            distanceChanged;\n        if (containerChanged || disabledChanged || distanceChanged) {\n            this.destroyScroller();\n            if (shouldSetup) {\n                this.setup();\n            }\n        }\n    }\n    setup() {\n        if (hasWindowDefined()) {\n            this.zone.runOutsideAngular(() => {\n                this.disposeScroller = createScroller({\n                    fromRoot: this.fromRoot,\n                    alwaysCallback: this.alwaysCallback,\n                    disable: this.infiniteScrollDisabled,\n                    downDistance: this.infiniteScrollDistance,\n                    element: this.element,\n                    horizontal: this.horizontal,\n                    scrollContainer: this.infiniteScrollContainer,\n                    scrollWindow: this.scrollWindow,\n                    throttle: this.infiniteScrollThrottle,\n                    upDistance: this.infiniteScrollUpDistance,\n                }).subscribe((payload) => this.handleOnScroll(payload));\n            });\n        }\n    }\n    handleOnScroll({ type, payload }) {\n        const emitter = type === InfiniteScrollActions.DOWN ? this.scrolled : this.scrolledUp;\n        if (hasObservers(emitter)) {\n            this.zone.run(() => emitter.emit(payload));\n        }\n    }\n    ngOnDestroy() {\n        this.destroyScroller();\n    }\n    destroyScroller() {\n        if (this.disposeScroller) {\n            this.disposeScroller.unsubscribe();\n        }\n    }\n}\nInfiniteScrollDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: InfiniteScrollDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nInfiniteScrollDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.3\", type: InfiniteScrollDirective, selector: \"[infiniteScroll], [infinite-scroll], [data-infinite-scroll]\", inputs: { infiniteScrollDistance: \"infiniteScrollDistance\", infiniteScrollUpDistance: \"infiniteScrollUpDistance\", infiniteScrollThrottle: \"infiniteScrollThrottle\", infiniteScrollDisabled: \"infiniteScrollDisabled\", infiniteScrollContainer: \"infiniteScrollContainer\", scrollWindow: \"scrollWindow\", immediateCheck: \"immediateCheck\", horizontal: \"horizontal\", alwaysCallback: \"alwaysCallback\", fromRoot: \"fromRoot\" }, outputs: { scrolled: \"scrolled\", scrolledUp: \"scrolledUp\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: InfiniteScrollDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { scrolled: [{\n                type: Output\n            }], scrolledUp: [{\n                type: Output\n            }], infiniteScrollDistance: [{\n                type: Input\n            }], infiniteScrollUpDistance: [{\n                type: Input\n            }], infiniteScrollThrottle: [{\n                type: Input\n            }], infiniteScrollDisabled: [{\n                type: Input\n            }], infiniteScrollContainer: [{\n                type: Input\n            }], scrollWindow: [{\n                type: Input\n            }], immediateCheck: [{\n                type: Input\n            }], horizontal: [{\n                type: Input\n            }], alwaysCallback: [{\n                type: Input\n            }], fromRoot: [{\n                type: Input\n            }] } });\nfunction hasObservers(emitter) {\n    // Note: The `observed` property is available only in RxJS@7.2.0, which means it's\n    // not available for users running the lower version.\n    return emitter.observed ?? emitter.observers.length > 0;\n}\n\nclass InfiniteScrollModule {\n}\nInfiniteScrollModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: InfiniteScrollModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nInfiniteScrollModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.0.3\", ngImport: i0, type: InfiniteScrollModule, declarations: [InfiniteScrollDirective], exports: [InfiniteScrollDirective] });\nInfiniteScrollModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: InfiniteScrollModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: i0, type: InfiniteScrollModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [InfiniteScrollDirective],\n                    exports: [InfiniteScrollDirective],\n                    imports: [],\n                    providers: [],\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-infinite-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule, NgxInfiniteScrollService };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}